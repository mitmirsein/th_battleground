
import json
from pathlib import Path
from datetime import datetime

# Translations for the next batch (generated by Antigravity)
BATCH_TRANSLATIONS = {
    "0626_002": """1.3.1. '일의적'(univok, 명료함)이라는 표현은 대상(사물, 행위, 태도, 상황, 상태 등을 가리키는 빈 술어로서의 '대상')을 지칭할 때 동일한 의미로 사용되는 경우를 말한다. '다의적'(aequivok, 모호함)이라는 표현은 서로 다른 대상을 지칭할 때 서로 다른 의미로 사용되는 경우를 말한다. 예를 들어 'Strauß'라는 표현은 새의 한 종류(타조)를 가리키는 술어로, 꽃다발을 가리키는 술어로, 혹은 사람의 고유명사(슈트라우스)로 사용될 수 있다. 다의적 표현과 그 사용에 있어서 우리는 두 가지 하위 분류를 나눌 수 있다. 하나는 우연히 다의적으로 사용된 표현들(aequivocatio a casu)이고, 다른 하나는 의도적으로 도입되거나 사용된 다의적 표현들(aequivocatio a consilio), 예를 들어 'Strauß'라는 표현을 이용한 의도적인 언어유희가 여기에 속한다.""",
    
    "0627_003": """1.3.3. 스콜라 철학 전통에서는 두 유사한 사물 사이의 관계를 '비례의 유비'(analogia proportionis)라고 불렀다. 그 예로 두 형제 사이의 형제 관계를 들 수 있다. 그러나 이 '유비'의 경우에도 엄밀한 의미에서는 일의적(univok) 언어 사용에 해당한다. '형제 관계'라는 술어는 개별적인 특성, 즉 한 형제가 다른 형제에 대해 가지는 구체적인 관계를 사상(abstrahieren)하고 사용된 것이기 때문이다.""",
    
    "0627_004": """1.3.4. 우리 언어에서 관찰할 수 있듯이, 표현들은 일반적으로 고정된 의미와 주된 용법을 가지고 있다. 예를 들어 '사자'라는 단어는 일반적으로 그 외연(Extension)이 유한한 수의 대상(특정 동물들)을 지칭하고, 그 내포(Intension, 의미)가 고정되어 있는(예: 사자는 동물이다, 사자는 강하다, 용감하다) 방식으로 사용된다. 이러한 주된 언어 관습을 은유적 화법에서 활용한다. 예를 들어 "아킬레우스는 사자다"라는 은유적 진술에서는 친숙함과 낯섦의 변증법이 작동한다. 어떤 사실(아킬레우스는 용감하다)을 지칭하기 위해 비일상적인 단어(사자)를 사용하고, 이 단어를 비일상적인 의미로 사용함으로써 사실관계와 언어 관습 모두를 낯설게 만드는 것이다.""",
    
    "0627_005": """(이어서)... 은유적 진술의 해독은 차이점 속에 있는 공통점, 비유사성 속에 있는 유사성을 드러내는 데 있다. 앞선 예시에서는 '사자'라는 표현의 내포 중에서 "동물이다", "고기를 먹는다"라는 부분 내포가 아니라, "용감하다", "강하다", "동물의 왕-전사의 왕"이라는 부분 내포가 사자와 아킬레우스에게 공통적으로 적용된다는 것을 인식하는 것이 핵심이다. ... 아리스토텔레스는 은유 형성을 ... 유비 형성에 근거한 것으로 특성 지었다. ... 은유 형성을 주된 언어 관습과 낯선 언어 관습 사이의 유희로 규정하고, 은유 형성 내에서 암시적 유비와 명시적 유비를 구분하는 것이 바람직하다. 암시적 유비는 "아킬레우스는 사자다"와 같은 은유적 어구와 진술을 의미한다. 이는 (복잡하고 더 이상 발견의 흥미를 주지 못하는) 관계의 대응으로 변형될 수 있다: 아킬레우스와 용기의 관계는 용기와 사자의 관계와 같다."""
}

def run_batch_update():
    path = Path("/Users/msn/Desktop/MS_Dev.nosync/data/msn_th_archive/translations/TRE_Analogie_KR.jsonl")
    
    updated_records = []
    updated_count = 0
    
    # Read existing
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            record = json.loads(line)
            chunk_id = record.get("chunk_id")
            
            # Update if we have a translation
            if chunk_id in BATCH_TRANSLATIONS:
                record["translation"] = BATCH_TRANSLATIONS[chunk_id]
                record["metadata"]["status"] = "done"
                record["timestamp"] = datetime.now().isoformat()
                updated_count += 1
                
            updated_records.append(record)
            
    # Write back
    with open(path, "w", encoding="utf-8") as f:
        for record in updated_records:
            f.write(json.dumps(record, ensure_ascii=False) + "\n")
            
    print(f"✅ Updated {updated_count} chunks with verified translations.")

if __name__ == "__main__":
    run_batch_update()
